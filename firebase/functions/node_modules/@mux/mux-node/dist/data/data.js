"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/data/data.ts
var data_exports = {};
__export(data_exports, {
  Data: () => Data
});
module.exports = __toCommonJS(data_exports);

// src/base.ts
var import_axios = __toESM(require("axios"));
var import_events = __toESM(require("events"));

// src/version.ts
var VERSION = "7.3.5";

// src/base.ts
var Base = class extends import_events.default {
  constructor(tokenIdOrOptionsOrBase, tokenSecret, config) {
    var _a, _b, _c, _d, _e, _f, _g;
    super();
    if (tokenIdOrOptionsOrBase instanceof Base) {
      this.config = tokenIdOrOptionsOrBase._config;
      this._tokenId = tokenIdOrOptionsOrBase._tokenId;
      this._tokenSecret = tokenIdOrOptionsOrBase._tokenSecret;
      this.http = tokenIdOrOptionsOrBase.http;
    } else {
      if (typeof tokenIdOrOptionsOrBase === "object" && !(tokenIdOrOptionsOrBase instanceof Base)) {
        this.config = tokenIdOrOptionsOrBase;
        this.tokenId = void 0;
        this.tokenSecret = void 0;
      } else {
        this.tokenId = tokenIdOrOptionsOrBase;
        this.tokenSecret = tokenSecret;
        this.config = config ?? {};
      }
      const request = {
        baseURL: this.config.baseUrl,
        headers: {
          "User-Agent": `Mux Node | ${VERSION}`,
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        withCredentials: false,
        auth: {
          username: this._tokenId,
          password: this._tokenSecret
        }
      };
      if ((_a = this.config.platform) == null ? void 0 : _a.name) {
        if ((_c = (_b = this.config.platform) == null ? void 0 : _b.name) == null ? void 0 : _c.includes("|")) {
          throw new Error('Platform name cannot contain a "|" value.');
        }
        if ((_e = (_d = this.config.platform) == null ? void 0 : _d.version) == null ? void 0 : _e.includes("|")) {
          throw new Error('Platform version cannot contain a "|" value.');
        }
        request.headers["x-source-platform"] = `${(_f = this.config.platform) == null ? void 0 : _f.name} | ${(_g = this.config.platform) == null ? void 0 : _g.version}`;
      }
      this.http = import_axios.default.create(request);
      this.http.interceptors.request.use((req) => {
        this.emit("request", req);
        return req;
      });
      this.http.interceptors.response.use(
        (res) => {
          this.emit("response", res);
          if (res.config.url && this.isVideoUrl(res.config.url)) {
            return res.data && res.data.data;
          }
          return res.data;
        },
        (errorRes) => Promise.reject(
          errorRes.response && errorRes.response.data.error || errorRes
        )
      );
    }
  }
  // eslint-disable-next-line class-methods-use-this
  isVideoUrl(url) {
    return url.startsWith(`/video/v1/`);
  }
  set config(options) {
    this._config = {
      baseUrl: "https://api.mux.com",
      ...options
    };
  }
  get config() {
    return this._config;
  }
  set tokenId(token) {
    const v = token || process.env.MUX_TOKEN_ID;
    if (!v || v.length === 0) {
      throw new Error("API Access Token must be provided.");
    }
    this._tokenId = v;
  }
  get tokenId() {
    return this._tokenId;
  }
  set tokenSecret(secret) {
    const v = secret || process.env.MUX_TOKEN_SECRET;
    if (!v || v.length === 0) {
      throw new Error("API secret key must be provided");
    }
    this._tokenSecret = v;
  }
  get tokenSecret() {
    return this._tokenSecret;
  }
};

// src/data/resources/errors.ts
var PATH = "/data/v1/errors";
var Errors = class extends Base {
  /**
   * Returns a list of playback errors
   *
   * @param {Object} [params] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Data } = new Mux(accessToken, secret);
   *
   * // Returns a list of playback errors filtered by the windows operating system
   * Data.Errors.list({ filters: ['operating_system:windows'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-errors
   */
  list(params) {
    return this.http.get(PATH, { params });
  }
};

// src/data/resources/exports.ts
var PATH2 = "/data/v1/exports";
var Exports = class extends Base {
  /**
   * Lists the available video view exports along with URLs to retrieve them
   * @extends Base
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Lists the available video view exports along with URLs to retrieve them
   * Data.Exports.list();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-exports
   */
  list() {
    return this.http.get(PATH2);
  }
};

// src/data/resources/filters.ts
var PATH3 = "/data/v1/filters";
var Filters = class extends Base {
  /**
   * Lists the values for a filter along with a total count of related views
   *
   * @param {string} filterId - The filter name/id for see https://api-docs.mux.com/#filter-get-1 for a list of all filter ids
   * @param {Object} [queryParams] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Lists the values for a filter along with a total count of related views
   * Data.Filters.get('browser', { timeframe: ['7:days'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-filter-values
   *
   * @deprecated The method should not be used, you should use Dimensions.get instead
   */
  get(filterId, params) {
    process.emitWarning(
      "The Filter API has been deprecated, please use Dimension instead",
      "DeprecatedWarning"
    );
    if (!filterId) {
      throw new Error("Filter Id is required to get filter information.");
    }
    return this.http.get(`${PATH3}/${filterId}`, { params });
  }
  /**
   * Lists all the filters broken out into basic and advanced
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Lists the available video view exports along with URLs to retrieve them
   * Data.Filters.list();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-filters
   *
   * @deprecated The method should not be used, you should use Dimensions.list instead
   */
  list() {
    process.emitWarning(
      "The Filter API has been deprecated, please use Dimension instead",
      "DeprecatedWarning"
    );
    return this.http.get(PATH3);
  }
};

// src/data/resources/dimensions.ts
var PATH4 = "/data/v1/dimensions";
var Dimensions = class extends Base {
  /**
   * Lists the values for a dimension along with a total count of related views
   *
   * @param {string} dimensionId - The dimension name/id, see https://docs.mux.com/api-reference/data#operation/list-dimensions for a list of all dimensions
   * @param {Object} [queryParams] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Lists the values for a dimension along with a total count of related views
   * Data.Dimensions.get('browser', { timeframe: ['7:days'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-dimension-values
   */
  get(dimensionId, params) {
    if (!dimensionId) {
      throw new Error("Dimension Id is required to get dimension information.");
    }
    return this.http.get(`${PATH4}/${dimensionId}`, { params });
  }
  /**
   * Lists all the dimensions broken out into basic and advanced
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Lists the available Data dimensions
   * Data.Dimensions.list();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-dimensions
   */
  list() {
    return this.http.get(PATH4);
  }
};

// src/data/resources/incidents.ts
var PATH5 = "/data/v1/incidents";
var Incidents = class extends Base {
  /**
   * Returns a list of all open incidents
   *
   * @param {Object} [params] - example { status: 'open', severity: 'warning' }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Data } = new Mux(accessToken, secret);
   *
   * // Returns a list of all open incidents
   * Data.Incidents.list({ status: 'open' });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-incidents
   */
  list(params) {
    return this.http.get(PATH5, { params });
  }
  /**
   * Returns the details for a single incident
   *
   * @param {string} incidentId - The ID for the incident
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * //Returns the details for a single incident
   * Data.Incidents.get('ABCD1234');
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-incident
   */
  get(incidentId) {
    if (!incidentId) {
      throw new Error("An incident id is required for incident details.");
    }
    return this.http.get(`${PATH5}/${incidentId}`);
  }
  /**
   * Returns all the incidents that seem related to a specific incident
   *
   * @param {string} incidentId - The ID for the incident
   * @param {Object} [params] - example { measurement: 'median' }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * //Returns all the incidents that seem related to a specific incident
   * Data.Incidents.related('ABCD1234');
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-related-incidents
   */
  related(incidentId, params) {
    if (!incidentId) {
      throw new Error("An incident id is required for related incidents.");
    }
    return this.http.get(`${PATH5}/${incidentId}/related`, { params });
  }
};

// src/data/resources/metrics.ts
var PATH6 = "/data/v1/metrics";
var Metrics = class extends Base {
  /**
   * List the breakdown values for a specific metric
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#breakdown-get for a list of all metric ids
   * @param {Object} params - example: {group_by: 'browser'}
   * NOTE: the group_by query parameter is required
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List all of the values across every breakdown for a specific metric grouped by browser
   * Data.Metrics.breakdown('aggregate_startup_time', { group_by: 'browser' });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-breakdown-values
   */
  breakdown(metricId, params) {
    return this.http.get(`${PATH6}/${metricId}/breakdown`, { params });
  }
  /**
   * List all of the values across every breakdown for a specific metric
   *
   * @param {Object} params - example { value: 'safari', timeframe: '24:hours', dimension: 'cdn' }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List the breakdown values for a specific metric within the last 24 hours
   * Data.Metrics.comparison({ value: 'safari', timeframe: '24:hours', dimension: 'cdn' });
   * Note: the value query parameter is required
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-all-metric-values
   */
  comparison(params) {
    if (!params || params && !params.value) {
      throw new Error(
        "The value query parameter is required for comparing metrics"
      );
    }
    return this.http.get(`${PATH6}/comparison`, { params });
  }
  /**
   * Returns a list of insights for a metric. These are the worst performing values across all
   * breakdowns sorted by how much they negatively impact a specific metric.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#breakdown-get for a list of all metric ids
   * @param {Object} [params] - example { measurement: 'median', order_direction: 'desc' }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Get a list of insights for a metric measured by median and ordered descending
   * Data.Metrics.insights('aggregate_startup_time', { measurement: 'median', order_direction: 'desc' });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-insights
   */
  insights(metricId, params) {
    if (!metricId) {
      throw new Error("A metric Id is required for insight metrics.");
    }
    return this.http.get(`${PATH6}/${metricId}/insights`, { params });
  }
  /**
   * Returns the overall value for a specific metric, as well as the total view count,
   * watch time, and the Mux Global metric value for the metric.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#overall-get for a list of all metric ids
   * @param {Object} [params] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Get the overall value for a specific metric within the past 7 days
   * Data.Metrics.overall('aggregate_startup_time', { timeframe: ['7:days'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-overall-values
   */
  overall(metricId, params) {
    if (!metricId) {
      throw new Error("A metric Id is required for overall metrics.");
    }
    return this.http.get(`${PATH6}/${metricId}/overall`, { params });
  }
  /**
   * Returns timeseries data for a specific metric
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#timeseries for a list of all metric ids
   * @param {Object} [params] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Get timeseries data for a specific metric within the past 7 days
   * Data.Metrics.timeseries('aggregate_startup_time', { timeframe: ['7:days'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-metric-timeseries-data
   */
  timeseries(metricId, params) {
    if (!metricId) {
      throw new Error("A metric Id is required for timeseries metrics.");
    }
    return this.http.get(`${PATH6}/${metricId}/timeseries`, { params });
  }
};

// src/data/resources/real_time.ts
var PATH7 = "/data/v1/realtime";
var RealTime = class extends Base {
  /**
   * List of available real-time dimensions
   *
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Returns a list of available real-time dimensions
   * Data.RealTime.dimensions();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-realtime-dimensions
   *
   * @deprecated The method should not be used, you should use Monitoring.dimensions() instead
   */
  dimensions() {
    return this.http.get(`${PATH7}/dimensions`);
  }
  /**
   * List available real-time metrics
   *
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Returns a list of available real-time metrics
   * Data.RealTime.metrics();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-realtime-metrics
   *
   * @deprecated The method should not be used, you should use Monitoring.metrics() instead
   */
  metrics() {
    return this.http.get(`${PATH7}/metrics`);
  }
  /**
   * Get breakdown information for a specific dimension and metric along with the number of concurrent viewers and negative impact score.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#real-time-get-1 for a list of all metric ids
   * @param {Object} params - example { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List the breakdown information for current-concurrent-viewers by ASN for a specific time for the Windows operating system in the US
   * Data.RealTime.breakdown('current-concurrent-viewers', { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-realtime-breakdown
   *
   * @deprecated The method should not be used, you should use Monitoring.breakdown() instead
   */
  breakdown(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for real-time breakdown information"
      );
    }
    if (!params || params && !params.dimension) {
      throw new Error(
        "The dimension query parameter is required for real-time breakdown information"
      );
    }
    return this.http.get(`${PATH7}/metrics/${metricId}/breakdown`, { params });
  }
  /**
   * List histogram timeseries information for a specific metric
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#real-time-get-1 for a list of all metric ids
   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List histogram timeseries information for video-startup-time for the Windows operating system in the US
   * Data.RealTime.histogramTimeseries('video-startup-time', { filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-realtime-histogram-timeseries
   *
   * @deprecated The method should not be used, you should use Monitoring.histogramTimeseries() instead
   */
  histogramTimeseries(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for real-time histogram timeseries information"
      );
    }
    return this.http.get(`${PATH7}/metrics/${metricId}/histogram-timeseries`, {
      params
    });
  }
  /**
   * List timeseries information for a specific metric along with the number of concurrent viewers.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#real-time-get-1 for a list of all metric ids
   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List timeseries information for the playback-failure-percentage metric along with the number of concurrent viewers for the Windows operating system in the US
   * Data.RealTime.timeseries('playback-failure-percentage', { filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-realtime-timeseries
   *
   * @deprecated The method should not be used, you should use Monitoring.timeseries() instead
   */
  timeseries(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for real-time timeseries information."
      );
    }
    return this.http.get(`${PATH7}/metrics/${metricId}/timeseries`, {
      params
    });
  }
};

// src/data/resources/monitoring.ts
var PATH8 = "/data/v1/monitoring";
var Monitoring = class extends Base {
  /**
   * List of available monitoring dimensions
   *
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Returns a list of available monitoring dimensions
   * Data.Monitoring.dimensions();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-monitoring-dimensions
   */
  dimensions() {
    return this.http.get(`${PATH8}/dimensions`);
  }
  /**
   * List available monitoring metrics
   *
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Returns a list of available monitoring metrics
   * Data.Monitoring.metrics();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-monitoring-metrics
   */
  metrics() {
    return this.http.get(`${PATH8}/metrics`);
  }
  /**
   * Get breakdown information for a specific dimension and metric along with the number of concurrent viewers and negative impact score.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#monitoring-get-1 for a list of all metric ids
   * @param {Object} params - example { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List the breakdown information for current-concurrent-viewers by ASN for a specific time for the Windows operating system in the US
   * Data.Monitoring.breakdown('current-concurrent-viewers', { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-monitoring-breakdown
   */
  breakdown(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for monitoring breakdown information"
      );
    }
    if (!params || params && !params.dimension) {
      throw new Error(
        "The dimension query parameter is required for monitoring breakdown information"
      );
    }
    return this.http.get(`${PATH8}/metrics/${metricId}/breakdown`, { params });
  }
  /**
   * List histogram timeseries information for a specific metric
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#monitoring-get-1 for a list of all metric ids
   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List histogram timeseries information for video-startup-time for the Windows operating system in the US
   * Data.Monitoring.histogramTimeseries('video-startup-time', { filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-monitoring-histogram-timeseries
   */
  histogramTimeseries(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for monitoring histogram timeseries information"
      );
    }
    return this.http.get(`${PATH8}/metrics/${metricId}/histogram-timeseries`, {
      params
    });
  }
  /**
   * List timeseries information for a specific metric along with the number of concurrent viewers.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#monitoring-get-1 for a list of all metric ids
   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List timeseries information for the playback-failure-percentage metric along with the number of concurrent viewers for the Windows operating system in the US
   * Data.Monitoring.timeseries('playback-failure-percentage', { filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-monitoring-timeseries
   */
  timeseries(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for monitoring timeseries information."
      );
    }
    return this.http.get(`${PATH8}/metrics/${metricId}/timeseries`, {
      params
    });
  }
};

// src/data/resources/video_views.ts
var PATH9 = "/data/v1/video-views";
var VideoViews = class extends Base {
  /**
   * Returns a list of video views for a property that occurred within the specified timeframe.
   * Results are ordered by view_end, according to what you provide for order_direction.
   *
   * @extends Base
   * @param {Object} queryParams - example { viewer_id: 'ABCD1234', timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Returns a list of video views for a property that occurred within the specified timeframe.
   * Data.VideoViews.list({ viewer_id: 'ABCD1234', timeframe: ['7:days'], order_direction: 'asc' });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-video-views
   */
  list(params) {
    return this.http.get(PATH9, { params });
  }
  /**
   * Returns the details for a single video view
   *
   * @param {string} videoViewId - The ID for the video view
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * //Returns the details for a single video view
   * Data.VideoViews.get('ABCD1234');
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-video-view
   */
  get(videoViewId) {
    if (!videoViewId) {
      throw new Error("A video view Id is required for video view details.");
    }
    return this.http.get(`${PATH9}/${videoViewId}`);
  }
};

// src/data/data.ts
var Data = class extends Base {
  constructor(accessTokenOrConfigOrBase, secret, config) {
    var __super = (...args) => {
      super(...args);
    };
    if (accessTokenOrConfigOrBase instanceof Base) {
      __super(accessTokenOrConfigOrBase);
    } else if (typeof accessTokenOrConfigOrBase === "object") {
      __super(accessTokenOrConfigOrBase);
    } else {
      __super(accessTokenOrConfigOrBase, secret, config);
    }
    this.Errors = new Errors(this);
    this.Exports = new Exports(this);
    this.Filters = new Filters(this);
    this.Dimensions = new Dimensions(this);
    this.Incidents = new Incidents(this);
    this.Metrics = new Metrics(this);
    this.RealTime = new RealTime(this);
    this.Monitoring = new Monitoring(this);
    this.VideoViews = new VideoViews(this);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Data
});
/*!
 * Mux Errors
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Exports
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Filters
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Dimensions
 * Copyright(c) 2022 Mux Inc.
 */
/*!
 * Mux Incidents
 * Copyright(c) 2019 Mux Inc.
 */
/*!
 * Mux Metrics
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Real-Time
 * Copyright(c) 2020 Mux Inc.
 */
/*!
 * Mux Monitoring
 * Copyright(c) 2020 Mux Inc.
 */
/*!
 * Mux Video Views
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Data
 * Copyright(c) 2022 Mux Inc.
 */
module.exports = module.exports.default || module.exports;
//# sourceMappingURL=data.js.map