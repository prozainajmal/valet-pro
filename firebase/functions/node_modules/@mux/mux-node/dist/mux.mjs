// src/base.ts
import Axios from "axios";
import EventEmitter from "events";

// src/version.ts
var VERSION = "7.3.5";

// src/base.ts
var Base = class extends EventEmitter {
  constructor(tokenIdOrOptionsOrBase, tokenSecret, config) {
    var _a, _b, _c, _d, _e, _f, _g;
    super();
    if (tokenIdOrOptionsOrBase instanceof Base) {
      this.config = tokenIdOrOptionsOrBase._config;
      this._tokenId = tokenIdOrOptionsOrBase._tokenId;
      this._tokenSecret = tokenIdOrOptionsOrBase._tokenSecret;
      this.http = tokenIdOrOptionsOrBase.http;
    } else {
      if (typeof tokenIdOrOptionsOrBase === "object" && !(tokenIdOrOptionsOrBase instanceof Base)) {
        this.config = tokenIdOrOptionsOrBase;
        this.tokenId = void 0;
        this.tokenSecret = void 0;
      } else {
        this.tokenId = tokenIdOrOptionsOrBase;
        this.tokenSecret = tokenSecret;
        this.config = config ?? {};
      }
      const request = {
        baseURL: this.config.baseUrl,
        headers: {
          "User-Agent": `Mux Node | ${VERSION}`,
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        withCredentials: false,
        auth: {
          username: this._tokenId,
          password: this._tokenSecret
        }
      };
      if ((_a = this.config.platform) == null ? void 0 : _a.name) {
        if ((_c = (_b = this.config.platform) == null ? void 0 : _b.name) == null ? void 0 : _c.includes("|")) {
          throw new Error('Platform name cannot contain a "|" value.');
        }
        if ((_e = (_d = this.config.platform) == null ? void 0 : _d.version) == null ? void 0 : _e.includes("|")) {
          throw new Error('Platform version cannot contain a "|" value.');
        }
        request.headers["x-source-platform"] = `${(_f = this.config.platform) == null ? void 0 : _f.name} | ${(_g = this.config.platform) == null ? void 0 : _g.version}`;
      }
      this.http = Axios.create(request);
      this.http.interceptors.request.use((req) => {
        this.emit("request", req);
        return req;
      });
      this.http.interceptors.response.use(
        (res) => {
          this.emit("response", res);
          if (res.config.url && this.isVideoUrl(res.config.url)) {
            return res.data && res.data.data;
          }
          return res.data;
        },
        (errorRes) => Promise.reject(
          errorRes.response && errorRes.response.data.error || errorRes
        )
      );
    }
  }
  // eslint-disable-next-line class-methods-use-this
  isVideoUrl(url) {
    return url.startsWith(`/video/v1/`);
  }
  set config(options) {
    this._config = {
      baseUrl: "https://api.mux.com",
      ...options
    };
  }
  get config() {
    return this._config;
  }
  set tokenId(token) {
    const v = token || process.env.MUX_TOKEN_ID;
    if (!v || v.length === 0) {
      throw new Error("API Access Token must be provided.");
    }
    this._tokenId = v;
  }
  get tokenId() {
    return this._tokenId;
  }
  set tokenSecret(secret) {
    const v = secret || process.env.MUX_TOKEN_SECRET;
    if (!v || v.length === 0) {
      throw new Error("API secret key must be provided");
    }
    this._tokenSecret = v;
  }
  get tokenSecret() {
    return this._tokenSecret;
  }
};

// src/video/resources/assets.ts
var PATH = "/video/v1/assets";
var buildBasePath = (assetId) => `${PATH}/${assetId}`;
var Assets = class extends Base {
  /**
   * Creates a Mux asset with the specified JSON parameters
   * @param {Object} params - Asset JSON parameters (e.g input)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Create an asset
   * Video.Assets.create({input: 'https://storage.googleapis.com/muxdemofiles/mux-video-intro.mp4'});
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-asset
   */
  create(params) {
    if (!params) {
      return Promise.reject(
        new Error("Params are required for creating an asset")
      );
    }
    return this.http.post(PATH, params);
  }
  /**
   * Updates an existing asset with new parameters.
   *
   * @param {string} assetId - the ID of the asset
   * @param {Object} params - Asset JSON parameters (e.g passthrough)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   */
  async update(assetId, params) {
    if (!assetId || !params) {
      throw new Error("assetId and params are required.");
    }
    return this.http.patch(buildBasePath(assetId), params);
  }
  /**
   * Deletes a Mux asset
   * @param {string} assetId - The ID for the asset intended for deletion
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Delete an asset
   * Video.Assets.del(assetId);
   *
   * @see hhttps://docs.mux.com/api-reference/video#operation/delete-asset
   */
  del(assetId) {
    if (!assetId) {
      return Promise.reject(
        new Error("An asset ID is required to delete an asset")
      );
    }
    return this.http.delete(buildBasePath(assetId));
  }
  /**
   * Get an asset
   * @param {string} assetId - The ID for the asset
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Get an asset
   * Video.Assets.get(assetId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-asset
   */
  get(assetId) {
    if (!assetId) {
      return Promise.reject(
        new Error("An asset ID is required to get an asset")
      );
    }
    return this.http.get(buildBasePath(assetId));
  }
  /**
   * Get input info for an asset
   * @param {string} assetId - The ID for the asset
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Get input info for an asset
   * Video.Assets.inputInfo(assetId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-asset-input-info
   */
  inputInfo(assetId) {
    if (!assetId) {
      return Promise.reject(
        new Error("An asset ID is required to get input-info")
      );
    }
    return this.http.get(`${buildBasePath(assetId)}/input-info`);
  }
  /**
   * List all assets for a Mux Environment (tied to your access token)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // List all assets for a Mux Environment
   * Video.Assets.list();
   *
   * @see https://docs.mux.com/api-reference/video#operation/list-assets
   */
  list(params) {
    return this.http.get(PATH, { params });
  }
  /**
   * Return an asset playback id
   * @param {string} assetId - The ID for the asset
   * @param {string} playbackId - The ID for the playbackId
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Retrieve an asset playbackId
   * Video.Assets.playbackId(assetId, playbackId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-asset-playback-id
   */
  playbackId(assetId, playbackId) {
    if (!assetId) {
      return Promise.reject(new Error("An asset ID is required"));
    }
    if (!playbackId) {
      return Promise.reject(new Error("A playback ID is required"));
    }
    return this.http.get(
      `${buildBasePath(assetId)}/playback-ids/${playbackId}`
    );
  }
  /**
   * Create an asset playback id
   * @param {string} assetId - The ID for the asset
   * @param {Object} params - Asset JSON parameters (e.g playback_policy)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Create an asset playback ID
   * Video.Assets.createPlaybackId(assetId, { policy: 'public' });
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-asset-playback-id
   */
  createPlaybackId(assetId, params) {
    if (!assetId) {
      return Promise.reject(new Error("An asset ID is required"));
    }
    if (!params) {
      return Promise.reject(new Error("Playback ID params are required"));
    }
    return this.http.post(`${buildBasePath(assetId)}/playback-ids`, params);
  }
  /**
   * Delete an asset playback ID
   * @param {string} assetId - The ID for the asset
   * @param {string} playbackId - The ID for the asset playback ID to delete
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Delete an asset playback ID
   * Video.Assets.deletePlaybackId(assetId, { policy: 'public' });
   *
   * @see https://docs.mux.com/api-reference/video#operation/delete-asset-playback-id
   */
  deletePlaybackId(assetId, playbackId) {
    if (!assetId) {
      return Promise.reject(new Error("An asset ID is required"));
    }
    if (!playbackId) {
      return Promise.reject(new Error("A playback ID is required"));
    }
    return this.http.delete(
      `${buildBasePath(assetId)}/playback-ids/${playbackId}`
    );
  }
  /**
   * Create a subtitle text track
   * @param {string} assetId - The ID for the asset
   * @param {Object} params - subtitle text track JSON parameters
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Create an asset text track
   * Video.Assets.createTrack(assetId, {
   *   url: "https://example.com/myVIdeo_en.srt",
   *   type: "text",
   *   text_type: "subtitles",
   *   language_code: "en-US",
   * });
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-asset-track
   */
  createTrack(assetId, params) {
    if (!assetId) {
      return Promise.reject(new Error("An asset ID is required"));
    }
    if (!params) {
      return Promise.reject(new Error("Track params are required"));
    }
    return this.http.post(`${buildBasePath(assetId)}/tracks`, params);
  }
  /**
   * Delete an asset text track
   * @param {string} assetId - The ID for the asset
   * @param {string} trackId - The ID for the asset text track to delete
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Delete an asset text track
   * Video.Assets.deleteTrack(assetId, trackId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/delete-asset-track
   */
  deleteTrack(assetId, trackId) {
    if (!assetId) {
      return Promise.reject(new Error("An asset ID is required"));
    }
    if (!trackId) {
      return Promise.reject(new Error("A track ID is required"));
    }
    return this.http.delete(`${buildBasePath(assetId)}/tracks/${trackId}`);
  }
  /**
   * Update mp4 support for an asset
   * @param {Object} params - mp4 support JSON parameters
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Updates mp4 support for an asset
   * Video.Assets.updateMp4Support(assetId, {mp4_support: "standard"});
   *
   * @see https://docs.mux.com/api-reference/video#operation/update-asset-mp4-support
   */
  updateMp4Support(assetId, params) {
    if (!assetId) {
      return Promise.reject(new Error("An asset ID is required"));
    }
    if (!(params && params.mp4_support)) {
      return Promise.reject(new Error("params.mp4_support is required"));
    }
    return this.http.put(`${buildBasePath(assetId)}/mp4-support`, params);
  }
  /**
   * Update master access for an asset
   * @param {Object} params - master access JSON parameters
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Update master access for an asset
   * Video.Assets.updateMasterAccess(assetId, {master_access: "temporary"});
   *
   * @see https://docs.mux.com/api-reference/video#operation/update-asset-master-access
   */
  updateMasterAccess(assetId, params) {
    if (!assetId) {
      return Promise.reject(new Error("An asset ID is required"));
    }
    if (!(params && params.master_access)) {
      return Promise.reject(new Error("params.master_access is required"));
    }
    return this.http.put(`${buildBasePath(assetId)}/master-access`, params);
  }
};

// src/video/resources/liveStreams.ts
var PATH2 = "/video/v1/live-streams";
var buildBasePath2 = (liveStreamId) => `${PATH2}/${liveStreamId}`;
var LiveStreams = class extends Base {
  /**
   * Creates a Mux live stream with the specified JSON parameters
   * @param {Object} params - Live Stream JSON parameters
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Video } = muxClient;
   *
   * // Create a live stream
   * Video.LiveStreams.create({
   *  playback_policy: 'public',
   *  new_asset_settings: { playback_policy: 'public' }
   * });
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-live-stream
   */
  create(params) {
    return this.http.post(PATH2, params);
  }
  /**
   * Updates an existing livestream with new parameters.
   *
   * @param {string} liveStreamId - the ID of the live stream
   * @param {Object} params - Live Stream JSON parameters (e.g playback_policy)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   */
  async update(liveStreamId, params) {
    if (!liveStreamId || !params) {
      throw new Error("assetId and params are required.");
    }
    return this.http.patch(buildBasePath2(liveStreamId), params);
  }
  /**
   * Deletes a Mux Live Stream
   * @param {string} liveStreamId - The ID for the live stream intended for deletion
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Delete a mux live stream
   * Video.LiveStreams.del(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/delete-live-stream
   */
  del(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to delete a live stream")
      );
    }
    return this.http.delete(buildBasePath2(liveStreamId));
  }
  /**
   * Get an Live Stream
   * @param {string} liveStreamId - The ID for the live stream
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Get a live stream
   * Video.LiveStreams.get(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-live-stream
   */
  get(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to get a live stream")
      );
    }
    return this.http.get(buildBasePath2(liveStreamId));
  }
  /**
   * List all live streams for a Mux Environment (tied to your access token)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // List all live streams for a Mux Environment
   * Video.LiveStreams.list();
   *
   * @see https://docs.mux.com/api-reference/video#operation/list-live-streams
   */
  list(params) {
    return this.http.get(PATH2, { params });
  }
  /**
   * Signal a live stream is finished
   * @param {string} liveStreamId - The ID for the live stream
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Signal a live stream is finished
   * Video.LiveStreams.signalComplete(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/signal-live-stream-complete
   */
  signalComplete(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to signal a stream is complete")
      );
    }
    return this.http.put(`${buildBasePath2(liveStreamId)}/complete`);
  }
  /**
   * Reset a stream key
   * @param {string} liveStreamId - The ID for the live stream
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Reset a live stream key if you want to immediately stop the current stream key
   * // from working and create a new stream key that can be used for future broadcasts.
   * Video.LiveStreams.resetStreamKey(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/reset-stream-key
   */
  resetStreamKey(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to reset a live stream key")
      );
    }
    return this.http.post(`${buildBasePath2(liveStreamId)}/reset-stream-key`);
  }
  /**
   * Create a live stream playback id
   * @param {string} liveStreamId - The ID for the live stream
   * @param {Object} params - Live Stream JSON parameters (e.g playback_policy)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Create a live stream playback ID
   * Video.LiveStreams.createPlaybackId(liveStreamId, { policy: 'public' });
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-live-stream-playback-id
   */
  createPlaybackId(liveStreamId, params) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error(
          "A live stream ID is required to create a live stream playback ID"
        )
      );
    }
    if (!params) {
      return Promise.reject(
        new Error(
          "A playback policy is required to create a live stream playback ID"
        )
      );
    }
    return this.http.post(
      `${buildBasePath2(liveStreamId)}/playback-ids`,
      params
    );
  }
  /**
   * Delete a live stream playback ID
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} playbackId - The ID for the live stream playback ID to delete
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Delete a live stream playback ID
   * Video.LiveStreams.deletePlaybackId(liveStreamId, { policy: 'public' });
   *
   * @see https://docs.mux.com/api-reference/video#operation/delete-live-stream-playback-id
   */
  deletePlaybackId(liveStreamId, playbackId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error(
          "A live stream ID is required to delete a live stream playback ID"
        )
      );
    }
    if (!playbackId) {
      return Promise.reject(
        new Error(
          "A live stream playback ID is required to delete a live stream playback ID"
        )
      );
    }
    return this.http.delete(
      `${buildBasePath2(liveStreamId)}/playback-ids/${playbackId}`
    );
  }
  /**
   * Return a live stream playback id
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} playbackId - The ID for the playbackId
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-asset-playback-id
   */
  playbackId(liveStreamId, playbackId) {
    if (!liveStreamId) {
      return Promise.reject(new Error("A live stream ID is required"));
    }
    if (!playbackId) {
      return Promise.reject(new Error("A playback ID is required"));
    }
    return this.http.get(
      `${buildBasePath2(liveStreamId)}/playback-ids/${playbackId}`
    );
  }
  /**
   * Create a simulcast target
   * @param {string} liveStreamId - The ID for the live stream
   * @param {Object} params - Simulcast Target JSON parameters (e.g url and stream_key)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Create a live simulcast target
   * Video.LiveStreams.createSimulcastTarget(liveStreamId, {url: 'rtmp://live.example.com/app', stream_key: 'difvbfgi', passthrough: 'Example Live Streaming service'});
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-live-stream-simulcast-target
   */
  createSimulcastTarget(liveStreamId, params) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to create a simulcast target")
      );
    }
    if (!(params && params.url)) {
      return Promise.reject(
        new Error("A url is required to create a simulcast target")
      );
    }
    return this.http.post(
      `${buildBasePath2(liveStreamId)}/simulcast-targets`,
      params
    );
  }
  /**
   * Get a simulcast target
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} simulcastTargetId - The ID for the simulcast target to delete
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Get a live simulcast target
   * Video.LiveStreams.getSimulcastTarget(liveStreamId, simulcastTargetId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-live-stream-simulcast-target
   */
  getSimulcastTarget(liveStreamId, simulcastTargetId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to get a simulcast target")
      );
    }
    if (!simulcastTargetId) {
      return Promise.reject(
        new Error("A simulcast target ID is required to get a simulcast target")
      );
    }
    return this.http.get(
      `${buildBasePath2(liveStreamId)}/simulcast-targets/${simulcastTargetId}`
    );
  }
  /**
   * Delete a simulcast target
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} simulcastTargetId - The ID for the simulcast target to delete
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Delete a simulcast target
   * Video.LiveStreams.deleteSimulcastTarget(liveStreamId, simulcastTargetId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/delete-live-stream-simulcast-target
   */
  deleteSimulcastTarget(liveStreamId, simulcastTargetId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to delete a simulcast target")
      );
    }
    if (!simulcastTargetId) {
      return Promise.reject(
        new Error(
          "A simulcast target ID is required to delete a simulcast target"
        )
      );
    }
    return this.http.delete(
      `${buildBasePath2(liveStreamId)}/simulcast-targets/${simulcastTargetId}`
    );
  }
  /**
   * Configures a live stream to receive embedded closed captions.
   * The resulting Asset's subtitle text track will have `closed_captions: true` set.
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} params - Embedded subtitles parameters.
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   */
  async updateEmbeddedSubtitles(liveStreamId, params) {
    if (!liveStreamId || !params) {
      throw new Error("liveStreamId and params are required.");
    }
    return this.http.put(
      `${buildBasePath2(liveStreamId)}/embedded-subtitles`,
      params
    );
  }
  /**
   * Configures a live stream to receive generated closed captions.
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} params - Generated subtitles parameters.
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   */
  async updateGeneratedSubtitles(liveStreamId, params) {
    if (!liveStreamId || !params) {
      throw new Error("liveStreamId and params are required.");
    }
    return this.http.put(
      `${buildBasePath2(liveStreamId)}/generated-subtitles`,
      params
    );
  }
  /**
   * Disable a Live Stream
   * @param {string} liveStreamId - The ID for the live stream
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Disable a live stream
   * Video.LiveStreams.disable(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/disable-live-stream
   */
  disable(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to disable a live stream")
      );
    }
    return this.http.put(`${buildBasePath2(liveStreamId)}/disable`);
  }
  /**
   * Enable a Live Stream
   * @param {string} liveStreamId - The ID for the live stream
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Enable a Live Stream
   * Video.LiveStreams.enable(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/enable-live-stream
   */
  enable(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to enable a live stream")
      );
    }
    return this.http.put(`${buildBasePath2(liveStreamId)}/enable`);
  }
};

// src/video/resources/playbackIds.ts
var PATH3 = "/video/v1/playback-ids";
var buildBasePath3 = (playbackId) => `${PATH3}/${playbackId}`;
var PlaybackIds = class extends Base {
  /**
   * Retrieve an Asset or Live Stream  identifier associated with a Playback ID
   * @param {string} playbackId - The ID for playback
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Retrieve an Asset or Live Stream identifier associated with a Playback ID
   * Video.PlaybackIds.get(playbackId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-asset-or-livestream-id
   */
  get(playbackId) {
    if (!playbackId) {
      return Promise.reject(
        new Error(
          "An playback ID is required to get an asset or live stream identifier"
        )
      );
    }
    return this.http.get(buildBasePath3(playbackId));
  }
};

// src/video/resources/uploads.ts
var PATH4 = "/video/v1/uploads";
var buildBasePath4 = (uploadId) => `${PATH4}/${uploadId}`;
var Uploads = class extends Base {
  /**
   * Creates a direct upload with the specified JSON parameters
   * @extends Base
   * @param {Object} params - Upload JSON parameters (e.g timeout)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Video } = muxClient;
   *
   * // Create a new upload
   * const upload = await Video.Uploads.create({new_asset_settings: {playback_policy: 'public'}});
   * // Now push a file to the URL returned.
   * fs.createReadStream(pathToFile).pipe(request.put(upload.url))
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-direct-upload
   */
  create(params) {
    if (!params) {
      return Promise.reject(
        new Error("Params are required for creating a direct upload")
      );
    }
    return this.http.post(PATH4, params);
  }
  /**
   * Cancels an upload
   * @param {string} uploadId - The ID for the upload intended for cancellation
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Cancels an upload
   * Video.Uploads.cancel(uploadId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/cancel-direct-upload
   */
  cancel(uploadId) {
    if (!uploadId) {
      return Promise.reject(new Error("An upload ID is required"));
    }
    return this.http.put(`${buildBasePath4(uploadId)}/cancel`);
  }
  /**
   * Get an upload
   * @param {string} uploadId - The ID for the upload
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Get an upload
   * Video.Uploads.get(uploadId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-direct-upload
   */
  get(uploadId) {
    if (!uploadId) {
      return Promise.reject(
        new Error("An upload ID is required to get an asset")
      );
    }
    return this.http.get(buildBasePath4(uploadId));
  }
  /**
   * List all uploads
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // List all uploads
   * Video.Uploads.list();
   *
   * @see https://docs.mux.com/api-reference/video#operation/list-direct-uploads
   */
  list(params) {
    return this.http.get(PATH4, { params });
  }
};

// src/video/resources/signingKeys.ts
var PATH5 = "/video/v1/signing-keys";
var buildBasePath5 = (keyId) => `${PATH5}/${keyId}`;
var SigningKeys = class extends Base {
  /**
   * Creates a new Signing Key that can be used with the JWT module to sign URLs.
   * @extends Base
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Video } = muxClient;
   *
   * // Create a new signing key
   * Video.SigningKeys.create();
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-url-signing-key
   */
  create() {
    return this.http.post(PATH5, {});
  }
  /**
   * Get a signing key. *Note* The private key is _not_ returned.
   * @param {string} keyId - The ID for the signing key
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Get a signing key
   * Video.SigningKeys.get(keyId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-url-signing-key
   */
  get(keyId) {
    if (!keyId) {
      return Promise.reject(new Error("An signing key ID is required."));
    }
    return this.http.get(buildBasePath5(keyId));
  }
  /**
   * Delete a signing key
   * @param {string} keyId - The ID for the signing key
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Delete a signing key
   * Video.SigningKeys.del(keyId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/delete-url-signing-key
   */
  del(keyId) {
    if (!keyId) {
      return Promise.reject(new Error("An signing key ID is required."));
    }
    return this.http.delete(buildBasePath5(keyId));
  }
  /**
   * List signing keys
   * @param {string} keyId - The ID for the signing key
   * @param {object} params - Object to include as query params
   * @param {number} params.limit - Number of signing keys to return in the response
   * @param {number} params.page - Page of signing keys to return (limit * page)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // List all signing keys
   * Video.SigningKeys.list();
   *
   * @see https://docs.mux.com/api-reference/video#operation/list-url-signing-keys
   */
  list(params = {}) {
    return this.http.get(PATH5, { params });
  }
};

// src/video/resources/deliveryUsage.ts
var PATH6 = "/video/v1/delivery-usage";
var DeliveryUsage = class extends Base {
  /**
   * List all delivery usage during a timeframe for a Mux Environment (tied to your access token)
   * @param {Object} params - Request JSON parameters (e.g timeframe)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // List all delivery usage for a Mux Environment within a timeframe
   * Video.DeliveryUsage.list({timeframe: [1574076240, 1573471440]});
   *
   * @see https://docs.mux.com/api-reference/video#operation/list-delivery-usage
   */
  list(params) {
    return this.http.get(PATH6, { params });
  }
};

// src/video/resources/playbackRestrictions.ts
var PATH7 = "/video/v1/playback-restrictions";
var buildBasePath6 = (restrictionId) => `${PATH7}/${restrictionId}`;
var PlaybackRestrictions = class extends Base {
  create(restriction) {
    return this.http.post(PATH7, restriction);
  }
  list() {
    return this.http.get(PATH7);
  }
  get(restrictionId) {
    return this.http.get(buildBasePath6(restrictionId));
  }
  delete(restrictionId) {
    return this.http.delete(buildBasePath6(restrictionId));
  }
  putReferrer(restrictionId, referrer) {
    return this.http.put(`${buildBasePath6(restrictionId)}/referrer`, referrer);
  }
};

// src/video/resources/spaces.ts
var BASE_PATH = "/video/v1/spaces";
var SPACE_PATH = (spaceId) => `${BASE_PATH}/${spaceId}`;
var BROADCAST_PATH = (spaceId, broadcastId) => `${SPACE_PATH(spaceId)}/broadcasts/${broadcastId}`;
var Broadcasts = class extends Base {
  create(spaceId, request) {
    return this.http.post(`${SPACE_PATH(spaceId)}/broadcasts`, request);
  }
  get(spaceId, broadcastId) {
    return this.http.get(BROADCAST_PATH(spaceId, broadcastId));
  }
  delete(spaceId, broadcastId) {
    return this.http.delete(BROADCAST_PATH(spaceId, broadcastId));
  }
  start(spaceId, broadcastId) {
    return this.http.post(`${BROADCAST_PATH(spaceId, broadcastId)}/start`);
  }
  stop(spaceId, broadcastId) {
    return this.http.post(`${BROADCAST_PATH(spaceId, broadcastId)}/stop`);
  }
};
var Spaces = class extends Base {
  constructor(accessTokenOrConfigOrBase, secret, config) {
    var __super = (...args) => {
      super(...args);
    };
    if (accessTokenOrConfigOrBase instanceof Base) {
      __super(accessTokenOrConfigOrBase);
    } else if (typeof accessTokenOrConfigOrBase === "object") {
      __super(accessTokenOrConfigOrBase);
    } else {
      __super(accessTokenOrConfigOrBase, secret, config ?? {});
    }
    this.Broadcasts = new Broadcasts(this);
  }
  create(req) {
    return this.http.post(BASE_PATH, req);
  }
  list(params) {
    return this.http.get(BASE_PATH, { params });
  }
  get(spaceId) {
    return this.http.get(SPACE_PATH(spaceId));
  }
  delete(spaceId) {
    return this.http.delete(SPACE_PATH(spaceId));
  }
};

// src/video/resources/transcriptionVocabularies.ts
var PATH8 = "/video/v1/transcription-vocabularies";
var buildBasePath7 = (transcriptionVocabularyId) => `${PATH8}/${transcriptionVocabularyId}`;
var TranscriptionVocabularies = class extends Base {
  create(transcriptionVocabulary) {
    return this.http.post(PATH8, transcriptionVocabulary);
  }
  list() {
    return this.http.get(PATH8);
  }
  get(transcriptionVocabularyId) {
    return this.http.get(buildBasePath7(transcriptionVocabularyId));
  }
  delete(transcriptionVocabularyId) {
    return this.http.delete(buildBasePath7(transcriptionVocabularyId));
  }
  update(transcriptionVocabularyId, transcriptionVocabulary) {
    return this.http.put(
      `${buildBasePath7(transcriptionVocabularyId)}`,
      transcriptionVocabulary
    );
  }
};

// src/video/video.ts
var Video = class extends Base {
  constructor(accessTokenOrConfigOrBase, secret, config) {
    var __super = (...args) => {
      super(...args);
    };
    if (accessTokenOrConfigOrBase instanceof Base) {
      __super(accessTokenOrConfigOrBase);
    } else if (typeof accessTokenOrConfigOrBase === "object") {
      __super(accessTokenOrConfigOrBase);
    } else {
      __super(accessTokenOrConfigOrBase, secret, config);
    }
    this.Assets = new Assets(this);
    this.LiveStreams = new LiveStreams(this);
    this.PlaybackIds = new PlaybackIds(this);
    this.Uploads = new Uploads(this);
    this.SigningKeys = new SigningKeys(this);
    this.DeliveryUsage = new DeliveryUsage(this);
    this.PlaybackRestrictions = new PlaybackRestrictions(this);
    this.Spaces = new Spaces(this);
    this.TranscriptionVocabularies = new TranscriptionVocabularies(this);
  }
};

// src/data/resources/errors.ts
var PATH9 = "/data/v1/errors";
var Errors = class extends Base {
  /**
   * Returns a list of playback errors
   *
   * @param {Object} [params] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Data } = new Mux(accessToken, secret);
   *
   * // Returns a list of playback errors filtered by the windows operating system
   * Data.Errors.list({ filters: ['operating_system:windows'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-errors
   */
  list(params) {
    return this.http.get(PATH9, { params });
  }
};

// src/data/resources/exports.ts
var PATH10 = "/data/v1/exports";
var Exports = class extends Base {
  /**
   * Lists the available video view exports along with URLs to retrieve them
   * @extends Base
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Lists the available video view exports along with URLs to retrieve them
   * Data.Exports.list();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-exports
   */
  list() {
    return this.http.get(PATH10);
  }
};

// src/data/resources/filters.ts
var PATH11 = "/data/v1/filters";
var Filters = class extends Base {
  /**
   * Lists the values for a filter along with a total count of related views
   *
   * @param {string} filterId - The filter name/id for see https://api-docs.mux.com/#filter-get-1 for a list of all filter ids
   * @param {Object} [queryParams] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Lists the values for a filter along with a total count of related views
   * Data.Filters.get('browser', { timeframe: ['7:days'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-filter-values
   *
   * @deprecated The method should not be used, you should use Dimensions.get instead
   */
  get(filterId, params) {
    process.emitWarning(
      "The Filter API has been deprecated, please use Dimension instead",
      "DeprecatedWarning"
    );
    if (!filterId) {
      throw new Error("Filter Id is required to get filter information.");
    }
    return this.http.get(`${PATH11}/${filterId}`, { params });
  }
  /**
   * Lists all the filters broken out into basic and advanced
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Lists the available video view exports along with URLs to retrieve them
   * Data.Filters.list();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-filters
   *
   * @deprecated The method should not be used, you should use Dimensions.list instead
   */
  list() {
    process.emitWarning(
      "The Filter API has been deprecated, please use Dimension instead",
      "DeprecatedWarning"
    );
    return this.http.get(PATH11);
  }
};

// src/data/resources/dimensions.ts
var PATH12 = "/data/v1/dimensions";
var Dimensions = class extends Base {
  /**
   * Lists the values for a dimension along with a total count of related views
   *
   * @param {string} dimensionId - The dimension name/id, see https://docs.mux.com/api-reference/data#operation/list-dimensions for a list of all dimensions
   * @param {Object} [queryParams] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Lists the values for a dimension along with a total count of related views
   * Data.Dimensions.get('browser', { timeframe: ['7:days'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-dimension-values
   */
  get(dimensionId, params) {
    if (!dimensionId) {
      throw new Error("Dimension Id is required to get dimension information.");
    }
    return this.http.get(`${PATH12}/${dimensionId}`, { params });
  }
  /**
   * Lists all the dimensions broken out into basic and advanced
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Lists the available Data dimensions
   * Data.Dimensions.list();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-dimensions
   */
  list() {
    return this.http.get(PATH12);
  }
};

// src/data/resources/incidents.ts
var PATH13 = "/data/v1/incidents";
var Incidents = class extends Base {
  /**
   * Returns a list of all open incidents
   *
   * @param {Object} [params] - example { status: 'open', severity: 'warning' }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Data } = new Mux(accessToken, secret);
   *
   * // Returns a list of all open incidents
   * Data.Incidents.list({ status: 'open' });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-incidents
   */
  list(params) {
    return this.http.get(PATH13, { params });
  }
  /**
   * Returns the details for a single incident
   *
   * @param {string} incidentId - The ID for the incident
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * //Returns the details for a single incident
   * Data.Incidents.get('ABCD1234');
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-incident
   */
  get(incidentId) {
    if (!incidentId) {
      throw new Error("An incident id is required for incident details.");
    }
    return this.http.get(`${PATH13}/${incidentId}`);
  }
  /**
   * Returns all the incidents that seem related to a specific incident
   *
   * @param {string} incidentId - The ID for the incident
   * @param {Object} [params] - example { measurement: 'median' }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * //Returns all the incidents that seem related to a specific incident
   * Data.Incidents.related('ABCD1234');
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-related-incidents
   */
  related(incidentId, params) {
    if (!incidentId) {
      throw new Error("An incident id is required for related incidents.");
    }
    return this.http.get(`${PATH13}/${incidentId}/related`, { params });
  }
};

// src/data/resources/metrics.ts
var PATH14 = "/data/v1/metrics";
var Metrics = class extends Base {
  /**
   * List the breakdown values for a specific metric
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#breakdown-get for a list of all metric ids
   * @param {Object} params - example: {group_by: 'browser'}
   * NOTE: the group_by query parameter is required
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List all of the values across every breakdown for a specific metric grouped by browser
   * Data.Metrics.breakdown('aggregate_startup_time', { group_by: 'browser' });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-breakdown-values
   */
  breakdown(metricId, params) {
    return this.http.get(`${PATH14}/${metricId}/breakdown`, { params });
  }
  /**
   * List all of the values across every breakdown for a specific metric
   *
   * @param {Object} params - example { value: 'safari', timeframe: '24:hours', dimension: 'cdn' }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List the breakdown values for a specific metric within the last 24 hours
   * Data.Metrics.comparison({ value: 'safari', timeframe: '24:hours', dimension: 'cdn' });
   * Note: the value query parameter is required
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-all-metric-values
   */
  comparison(params) {
    if (!params || params && !params.value) {
      throw new Error(
        "The value query parameter is required for comparing metrics"
      );
    }
    return this.http.get(`${PATH14}/comparison`, { params });
  }
  /**
   * Returns a list of insights for a metric. These are the worst performing values across all
   * breakdowns sorted by how much they negatively impact a specific metric.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#breakdown-get for a list of all metric ids
   * @param {Object} [params] - example { measurement: 'median', order_direction: 'desc' }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Get a list of insights for a metric measured by median and ordered descending
   * Data.Metrics.insights('aggregate_startup_time', { measurement: 'median', order_direction: 'desc' });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-insights
   */
  insights(metricId, params) {
    if (!metricId) {
      throw new Error("A metric Id is required for insight metrics.");
    }
    return this.http.get(`${PATH14}/${metricId}/insights`, { params });
  }
  /**
   * Returns the overall value for a specific metric, as well as the total view count,
   * watch time, and the Mux Global metric value for the metric.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#overall-get for a list of all metric ids
   * @param {Object} [params] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Get the overall value for a specific metric within the past 7 days
   * Data.Metrics.overall('aggregate_startup_time', { timeframe: ['7:days'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-overall-values
   */
  overall(metricId, params) {
    if (!metricId) {
      throw new Error("A metric Id is required for overall metrics.");
    }
    return this.http.get(`${PATH14}/${metricId}/overall`, { params });
  }
  /**
   * Returns timeseries data for a specific metric
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#timeseries for a list of all metric ids
   * @param {Object} [params] - example { timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Get timeseries data for a specific metric within the past 7 days
   * Data.Metrics.timeseries('aggregate_startup_time', { timeframe: ['7:days'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-metric-timeseries-data
   */
  timeseries(metricId, params) {
    if (!metricId) {
      throw new Error("A metric Id is required for timeseries metrics.");
    }
    return this.http.get(`${PATH14}/${metricId}/timeseries`, { params });
  }
};

// src/data/resources/real_time.ts
var PATH15 = "/data/v1/realtime";
var RealTime = class extends Base {
  /**
   * List of available real-time dimensions
   *
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Returns a list of available real-time dimensions
   * Data.RealTime.dimensions();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-realtime-dimensions
   *
   * @deprecated The method should not be used, you should use Monitoring.dimensions() instead
   */
  dimensions() {
    return this.http.get(`${PATH15}/dimensions`);
  }
  /**
   * List available real-time metrics
   *
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Returns a list of available real-time metrics
   * Data.RealTime.metrics();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-realtime-metrics
   *
   * @deprecated The method should not be used, you should use Monitoring.metrics() instead
   */
  metrics() {
    return this.http.get(`${PATH15}/metrics`);
  }
  /**
   * Get breakdown information for a specific dimension and metric along with the number of concurrent viewers and negative impact score.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#real-time-get-1 for a list of all metric ids
   * @param {Object} params - example { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List the breakdown information for current-concurrent-viewers by ASN for a specific time for the Windows operating system in the US
   * Data.RealTime.breakdown('current-concurrent-viewers', { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-realtime-breakdown
   *
   * @deprecated The method should not be used, you should use Monitoring.breakdown() instead
   */
  breakdown(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for real-time breakdown information"
      );
    }
    if (!params || params && !params.dimension) {
      throw new Error(
        "The dimension query parameter is required for real-time breakdown information"
      );
    }
    return this.http.get(`${PATH15}/metrics/${metricId}/breakdown`, { params });
  }
  /**
   * List histogram timeseries information for a specific metric
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#real-time-get-1 for a list of all metric ids
   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List histogram timeseries information for video-startup-time for the Windows operating system in the US
   * Data.RealTime.histogramTimeseries('video-startup-time', { filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-realtime-histogram-timeseries
   *
   * @deprecated The method should not be used, you should use Monitoring.histogramTimeseries() instead
   */
  histogramTimeseries(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for real-time histogram timeseries information"
      );
    }
    return this.http.get(`${PATH15}/metrics/${metricId}/histogram-timeseries`, {
      params
    });
  }
  /**
   * List timeseries information for a specific metric along with the number of concurrent viewers.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#real-time-get-1 for a list of all metric ids
   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List timeseries information for the playback-failure-percentage metric along with the number of concurrent viewers for the Windows operating system in the US
   * Data.RealTime.timeseries('playback-failure-percentage', { filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-realtime-timeseries
   *
   * @deprecated The method should not be used, you should use Monitoring.timeseries() instead
   */
  timeseries(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for real-time timeseries information."
      );
    }
    return this.http.get(`${PATH15}/metrics/${metricId}/timeseries`, {
      params
    });
  }
};

// src/data/resources/monitoring.ts
var PATH16 = "/data/v1/monitoring";
var Monitoring = class extends Base {
  /**
   * List of available monitoring dimensions
   *
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Returns a list of available monitoring dimensions
   * Data.Monitoring.dimensions();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-monitoring-dimensions
   */
  dimensions() {
    return this.http.get(`${PATH16}/dimensions`);
  }
  /**
   * List available monitoring metrics
   *
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Returns a list of available monitoring metrics
   * Data.Monitoring.metrics();
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-monitoring-metrics
   */
  metrics() {
    return this.http.get(`${PATH16}/metrics`);
  }
  /**
   * Get breakdown information for a specific dimension and metric along with the number of concurrent viewers and negative impact score.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#monitoring-get-1 for a list of all metric ids
   * @param {Object} params - example { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List the breakdown information for current-concurrent-viewers by ASN for a specific time for the Windows operating system in the US
   * Data.Monitoring.breakdown('current-concurrent-viewers', { dimension: 'asn', timestamp: 1547853000, filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-monitoring-breakdown
   */
  breakdown(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for monitoring breakdown information"
      );
    }
    if (!params || params && !params.dimension) {
      throw new Error(
        "The dimension query parameter is required for monitoring breakdown information"
      );
    }
    return this.http.get(`${PATH16}/metrics/${metricId}/breakdown`, { params });
  }
  /**
   * List histogram timeseries information for a specific metric
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#monitoring-get-1 for a list of all metric ids
   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List histogram timeseries information for video-startup-time for the Windows operating system in the US
   * Data.Monitoring.histogramTimeseries('video-startup-time', { filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-monitoring-histogram-timeseries
   */
  histogramTimeseries(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for monitoring histogram timeseries information"
      );
    }
    return this.http.get(`${PATH16}/metrics/${metricId}/histogram-timeseries`, {
      params
    });
  }
  /**
   * List timeseries information for a specific metric along with the number of concurrent viewers.
   *
   * @param {string} metricId - The metric name/id for see https://api-docs.mux.com/#monitoring-get-1 for a list of all metric ids
   * @param {Object} params - example { filters: ['operating_system:windows', 'country:US'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // List timeseries information for the playback-failure-percentage metric along with the number of concurrent viewers for the Windows operating system in the US
   * Data.Monitoring.timeseries('playback-failure-percentage', { filters: ['operating_system:windows', 'country:US'] });
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-monitoring-timeseries
   */
  timeseries(metricId, params) {
    if (!metricId) {
      throw new Error(
        "A metric Id is required for monitoring timeseries information."
      );
    }
    return this.http.get(`${PATH16}/metrics/${metricId}/timeseries`, {
      params
    });
  }
};

// src/data/resources/video_views.ts
var PATH17 = "/data/v1/video-views";
var VideoViews = class extends Base {
  /**
   * Returns a list of video views for a property that occurred within the specified timeframe.
   * Results are ordered by view_end, according to what you provide for order_direction.
   *
   * @extends Base
   * @param {Object} queryParams - example { viewer_id: 'ABCD1234', timeframe: ['7:days'], filters: ['operating_system:windows'] }
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * // Returns a list of video views for a property that occurred within the specified timeframe.
   * Data.VideoViews.list({ viewer_id: 'ABCD1234', timeframe: ['7:days'], order_direction: 'asc' });
   *
   * @see https://docs.mux.com/api-reference/data#operation/list-video-views
   */
  list(params) {
    return this.http.get(PATH17, { params });
  }
  /**
   * Returns the details for a single video view
   *
   * @param {string} videoViewId - The ID for the video view
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Data } = muxClient;
   *
   * //Returns the details for a single video view
   * Data.VideoViews.get('ABCD1234');
   *
   * @see https://docs.mux.com/api-reference/data#operation/get-video-view
   */
  get(videoViewId) {
    if (!videoViewId) {
      throw new Error("A video view Id is required for video view details.");
    }
    return this.http.get(`${PATH17}/${videoViewId}`);
  }
};

// src/data/data.ts
var Data = class extends Base {
  constructor(accessTokenOrConfigOrBase, secret, config) {
    var __super = (...args) => {
      super(...args);
    };
    if (accessTokenOrConfigOrBase instanceof Base) {
      __super(accessTokenOrConfigOrBase);
    } else if (typeof accessTokenOrConfigOrBase === "object") {
      __super(accessTokenOrConfigOrBase);
    } else {
      __super(accessTokenOrConfigOrBase, secret, config);
    }
    this.Errors = new Errors(this);
    this.Exports = new Exports(this);
    this.Filters = new Filters(this);
    this.Dimensions = new Dimensions(this);
    this.Incidents = new Incidents(this);
    this.Metrics = new Metrics(this);
    this.RealTime = new RealTime(this);
    this.Monitoring = new Monitoring(this);
    this.VideoViews = new VideoViews(this);
  }
};

// src/webhooks/resources/verify_header.ts
import crypto from "crypto";
var HeaderScheme = {
  V1: "v1"
};
var DEFAULT_TOLERANCE = 300;
var EXPECTED_SCHEME = HeaderScheme.V1;
function secureCompare(_a, _b) {
  const a = Buffer.from(_a);
  const b = Buffer.from(_b);
  if (a.length !== b.length) {
    return false;
  }
  if (crypto.timingSafeEqual) {
    return crypto.timingSafeEqual(a, b);
  }
  const len = a.length;
  let result = 0;
  for (let i = 0; i < len; i += 1) {
    result |= a[i] ^ b[i];
  }
  return result === 0;
}
var VerifyHeader = class {
  static parseHeader(header, scheme = HeaderScheme.V1) {
    if (typeof header !== "string") {
      return null;
    }
    if (scheme !== EXPECTED_SCHEME) {
      throw new Error(`Unrecognized header scheme: '${scheme}'`);
    }
    return header.split(",").reduce(
      (accum, item) => {
        const kv = item.split("=");
        if (kv[0] === "t") {
          accum.timestamp = parseInt(kv[1], 10);
        }
        if (kv[0] === scheme && typeof kv[1] === "string") {
          accum.signatures.push(kv[1]);
        }
        return accum;
      },
      {
        timestamp: -1,
        signatures: []
      }
    );
  }
  static computeSignature(payload, secret) {
    return crypto.createHmac("sha256", secret).update(payload, "utf8").digest("hex");
  }
  static verify(_payload, _header, secret, tolerance = DEFAULT_TOLERANCE) {
    const payload = Buffer.isBuffer(_payload) ? _payload.toString("utf8") : _payload;
    const header = Buffer.isBuffer(_header) ? _header.toString("utf8") : _header;
    const details = this.parseHeader(header);
    if (!details || details.timestamp === -1) {
      throw new Error("Unable to extract timestamp and signatures from header");
    }
    if (!details.signatures.length) {
      throw new Error("No signatures found with expected scheme");
    }
    const expectedSignature = this.computeSignature(
      `${details.timestamp}.${payload}`,
      secret
    );
    const signatureFound = !!details.signatures.filter(
      (sig) => secureCompare(sig, expectedSignature)
    ).length;
    if (!signatureFound) {
      throw new Error(
        "No signatures found matching the expected signature for payload."
      );
    }
    const timestampAge = Math.floor(Date.now() / 1e3) - details.timestamp;
    if (tolerance > 0 && timestampAge > tolerance) {
      throw new Error("Timestamp outside the tolerance zone");
    }
    return true;
  }
};

// src/webhooks/webhooks.ts
var Webhooks = class {
  /**
   * Verify a webhook signature. When enabled, Mux will send webhooks with a signature
   * in the http request header 'Mux-Signature'. You can use that signature to verify
   * that the webhook is indeed coming from Mux.
   *
   * @param {string} body - The raw request body from Mux. This is stringified JSON.
   * @param {string} signature - The signature that was in the request header.
   * @param {string} secret - The webhook signing secret (get this from your dashboard).
   * @returns {boolean} - Returns true if the signature is verified.
   *
   * @throws {Error} throw error when a webhook signature verification fails.
   *
   * @example
   * const Mux = require('@mux/mux-node');
   * const { Webhooks } = Mux;
   *
   * // Verify a webhook signature
   * Webhooks.verifyHeader(body, signature, secret);
   *
   * @see https://docs.mux.com/docs/webhook-security
   */
  static verifyHeader(body, signature, secret) {
    return VerifyHeader.verify(body, signature, secret);
  }
};

// src/utils/jwt.ts
import fs from "fs";
import jwt from "jsonwebtoken";
var TypeClaim = /* @__PURE__ */ ((TypeClaim2) => {
  TypeClaim2["video"] = "v";
  TypeClaim2["thumbnail"] = "t";
  TypeClaim2["gif"] = "g";
  TypeClaim2["storyboard"] = "s";
  TypeClaim2["stats"] = "playback_id";
  return TypeClaim2;
})(TypeClaim || {});
var DataTypeClaim = /* @__PURE__ */ ((DataTypeClaim2) => {
  DataTypeClaim2["video"] = "video_id";
  DataTypeClaim2["asset"] = "asset_id";
  DataTypeClaim2["playback"] = "playback_id";
  DataTypeClaim2["live_stream"] = "livestream_id";
  return DataTypeClaim2;
})(DataTypeClaim || {});
var getSigningKey = (options) => {
  const keyId = options.keyId || process.env.MUX_SIGNING_KEY;
  if (!keyId) {
    throw new TypeError("Signing Key ID required");
  }
  return keyId;
};
var getPrivateKey = (options) => {
  let key;
  if (options.keySecret) {
    key = options.keySecret;
  } else if (options.keyFilePath) {
    key = fs.readFileSync(options.keyFilePath);
  } else if (process.env.MUX_PRIVATE_KEY) {
    key = Buffer.from(process.env.MUX_PRIVATE_KEY, "base64");
  }
  if (Buffer.isBuffer(key)) {
    return key;
  }
  if (key) {
    const [rsaHeader] = key.toString().split("\n");
    if (rsaHeader === "-----BEGIN RSA PRIVATE KEY-----") {
      return key;
    }
    try {
      return Buffer.from(key, "base64");
    } catch (err) {
      throw new TypeError(
        "Specified signing key must be either a valid PEM string or a base64 encoded PEM."
      );
    }
  }
  throw new TypeError("Signing Key ID required");
};
var JWT = class {
  /**
   * Creates a new token to be used with a signed playback ID
   * @param {string} playbackId - The Playback ID (of type 'signed') that you'd like to generate a token for.
   * @param {Object} options - Configuration options to use when creating the token
   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted
   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.
   * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `thumbnail`, `gif`, `storyboard` or `stats`
   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.
   * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.
   * @returns {string} - Returns a token to be used with a signed URL.
   *
   * @example
   * const Mux = require('@mux/mux-node');
   *
   * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });
   * // Now you can use the token in a url: `https://stream.mux.com/some-playback-id.m3u8?token=${token}`
   *
   * @deprecated This method should not be used, you should use signPlaybackId instead
   */
  static sign(playbackId, options = {}) {
    process.emitWarning(
      "The JWT.sign() method has been deprecated, please use JWT.signPlaybackId() instead",
      "DeprecatedWarning"
    );
    return this.signPlaybackId(playbackId, options);
  }
  /**
   * Creates a new token to be used with a signed playback ID
   * @param {string} playbackId - The Playback ID (of type 'signed') that you'd like to generate a token for.
   * @param {Object} options - Configuration options to use when creating the token
   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted
   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.
   * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `thumbnail`, `gif`, `storyboard` or `stats`
   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.
   * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.
   * @returns {string} - Returns a token to be used with a signed URL.
   *
   * @example
   * const Mux = require('@mux/mux-node');
   *
   * const token = Mux.JWT.signPlaybackId('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });
   * // Now you can use the token in a url: `https://stream.mux.com/some-playback-id.m3u8?token=${token}`
   */
  static signPlaybackId(playbackId, options = {}) {
    const opts = {
      type: "video",
      expiration: "7d",
      params: {},
      ...options
    };
    const keyId = getSigningKey(options);
    const keySecret = getPrivateKey(options);
    const typeClaim = TypeClaim[opts.type];
    if (!typeClaim) {
      throw new Error(`Invalid signature type: ${opts.type}`);
    }
    const tokenOptions = {
      keyid: keyId,
      subject: playbackId,
      audience: typeClaim,
      expiresIn: opts.expiration,
      noTimestamp: true,
      algorithm: "RS256"
    };
    return jwt.sign(opts.params, keySecret, tokenOptions);
  }
  /**
   * Creates a new token to be used with a signed Space ID
   * @param {string} spaceId - The Space ID (of type 'signed') that you'd like to generate a token for.
   * @param {Object} options - Configuration options to use when creating the token
   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted
   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.
   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.
   * @param {Object} [options.params] - Any additional query params you'd use with a public url.
   * @returns {string} - Returns a token to be used with a signed URL.
   *
   * @example
   * const Mux = require('@mux/mux-node');
   *
   * const token = Mux.JWT.signSpaceId('some-space-id', { keyId: 'your key id', keySecret: 'your key secret' });
   */
  static signSpaceId(spaceId, options = {}) {
    const opts = {
      expiration: "7d",
      params: {},
      ...options
    };
    const keyId = getSigningKey(options);
    const keySecret = getPrivateKey(options);
    const tokenOptions = {
      keyid: keyId,
      subject: spaceId,
      audience: "rt",
      expiresIn: opts.expiration,
      noTimestamp: true,
      algorithm: "RS256"
    };
    if (!spaceId) {
      throw new TypeError("A valid Space ID is required");
    }
    return jwt.sign(opts.params, keySecret, tokenOptions);
  }
  /**
   * Creates a new token to be used with a signed statistics request
   * @param {string} Id - The ID of the object that you'd like to generate a token for
   * @param {Object} options - Configuration options to use when creating the token
   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted
   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.
   * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `asset`, `playback`, or `live_stream`
   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.
   * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.
   * @returns {string} - Returns a token to be used with a viewer count URL.
   *
   * @example
   * const Mux = require('@mux/mux-node');
   *
   * const token = Mux.JWT.signViewerCounts('some-id', { type: 'video', keyId: 'your key id', keySecret: 'your key secret' });
   * // Now you can use the token in a url: `https://stats.mux.com/counts?token=${token}`
   */
  static signViewerCounts(Id, options = {}) {
    const opts = {
      type: "video",
      expiration: "7d",
      params: {},
      ...options
    };
    const keyId = getSigningKey(options);
    const keySecret = getPrivateKey(options);
    const typeClaim = DataTypeClaim[opts.type];
    if (!typeClaim) {
      throw new Error(`Invalid signature type: ${opts.type}`);
    }
    const tokenOptions = {
      keyid: keyId,
      subject: Id,
      audience: typeClaim,
      expiresIn: opts.expiration,
      noTimestamp: true,
      algorithm: "RS256"
    };
    return jwt.sign(opts.params, keySecret, tokenOptions);
  }
  /**
   * Decodes an existing token.
   *
   * Note: This does not cryptographically verify the token signature, it simply decodes the values.
   * @param {string} token - The token you'd like to decode.
   * @returns {Object} - If the token could be decoded, it returns the decoded token object
   *
   * @example
   * const Mux = require('@mux/mux-node');
   *
   * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });
   * const decoded = Mux.JWT.decode(token);
   * // decoded will be the raw decoded JWT, so you'll see keys like `aud`, `exp`, etc.
   */
  static decode(token) {
    return jwt.decode(token);
  }
};

// src/mux.ts
var Mux = class extends Base {
  constructor(accessTokenOrConfig, secret, config) {
    var __super = (...args) => {
      super(...args);
    };
    accessTokenOrConfig = accessTokenOrConfig ?? {};
    if (typeof accessTokenOrConfig === "object") {
      __super(accessTokenOrConfig);
    } else {
      __super(accessTokenOrConfig, secret, config ?? {});
    }
    this.Video = new Video(this);
    this.Data = new Data(this);
  }
};
Mux.JWT = JWT;
Mux.Webhooks = Webhooks;
export {
  Mux as default
};
/*!
 * Mux Assets
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Live Streams
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Signing Keys
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux DeliveryUsage
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Video
 * Copyright(c) 2022 Mux Inc.
 */
/*!
 * Mux Errors
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Exports
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Filters
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Dimensions
 * Copyright(c) 2022 Mux Inc.
 */
/*!
 * Mux Incidents
 * Copyright(c) 2019 Mux Inc.
 */
/*!
 * Mux Metrics
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Real-Time
 * Copyright(c) 2020 Mux Inc.
 */
/*!
 * Mux Monitoring
 * Copyright(c) 2020 Mux Inc.
 */
/*!
 * Mux Video Views
 * Copyright(c) 2018 Mux Inc.
 */
/*!
 * Mux Data
 * Copyright(c) 2022 Mux Inc.
 */
/*!
 * JWT - Signed URL Helpers
 * Note: Hacking this module into a class with static methods because ESDoc forces it. We'll revisit ESDoc later.
 * Documentationjs looks real nice.
 */
/*!
 * Mux
 * Copyright(c) 2018 Mux Inc.
 */
//# sourceMappingURL=mux.mjs.map