"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/video/resources/uploads.ts
var uploads_exports = {};
__export(uploads_exports, {
  Uploads: () => Uploads
});
module.exports = __toCommonJS(uploads_exports);

// src/base.ts
var import_axios = __toESM(require("axios"));
var import_events = __toESM(require("events"));

// src/version.ts
var VERSION = "7.3.5";

// src/base.ts
var Base = class extends import_events.default {
  constructor(tokenIdOrOptionsOrBase, tokenSecret, config) {
    var _a, _b, _c, _d, _e, _f, _g;
    super();
    if (tokenIdOrOptionsOrBase instanceof Base) {
      this.config = tokenIdOrOptionsOrBase._config;
      this._tokenId = tokenIdOrOptionsOrBase._tokenId;
      this._tokenSecret = tokenIdOrOptionsOrBase._tokenSecret;
      this.http = tokenIdOrOptionsOrBase.http;
    } else {
      if (typeof tokenIdOrOptionsOrBase === "object" && !(tokenIdOrOptionsOrBase instanceof Base)) {
        this.config = tokenIdOrOptionsOrBase;
        this.tokenId = void 0;
        this.tokenSecret = void 0;
      } else {
        this.tokenId = tokenIdOrOptionsOrBase;
        this.tokenSecret = tokenSecret;
        this.config = config ?? {};
      }
      const request = {
        baseURL: this.config.baseUrl,
        headers: {
          "User-Agent": `Mux Node | ${VERSION}`,
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        withCredentials: false,
        auth: {
          username: this._tokenId,
          password: this._tokenSecret
        }
      };
      if ((_a = this.config.platform) == null ? void 0 : _a.name) {
        if ((_c = (_b = this.config.platform) == null ? void 0 : _b.name) == null ? void 0 : _c.includes("|")) {
          throw new Error('Platform name cannot contain a "|" value.');
        }
        if ((_e = (_d = this.config.platform) == null ? void 0 : _d.version) == null ? void 0 : _e.includes("|")) {
          throw new Error('Platform version cannot contain a "|" value.');
        }
        request.headers["x-source-platform"] = `${(_f = this.config.platform) == null ? void 0 : _f.name} | ${(_g = this.config.platform) == null ? void 0 : _g.version}`;
      }
      this.http = import_axios.default.create(request);
      this.http.interceptors.request.use((req) => {
        this.emit("request", req);
        return req;
      });
      this.http.interceptors.response.use(
        (res) => {
          this.emit("response", res);
          if (res.config.url && this.isVideoUrl(res.config.url)) {
            return res.data && res.data.data;
          }
          return res.data;
        },
        (errorRes) => Promise.reject(
          errorRes.response && errorRes.response.data.error || errorRes
        )
      );
    }
  }
  // eslint-disable-next-line class-methods-use-this
  isVideoUrl(url) {
    return url.startsWith(`/video/v1/`);
  }
  set config(options) {
    this._config = {
      baseUrl: "https://api.mux.com",
      ...options
    };
  }
  get config() {
    return this._config;
  }
  set tokenId(token) {
    const v = token || process.env.MUX_TOKEN_ID;
    if (!v || v.length === 0) {
      throw new Error("API Access Token must be provided.");
    }
    this._tokenId = v;
  }
  get tokenId() {
    return this._tokenId;
  }
  set tokenSecret(secret) {
    const v = secret || process.env.MUX_TOKEN_SECRET;
    if (!v || v.length === 0) {
      throw new Error("API secret key must be provided");
    }
    this._tokenSecret = v;
  }
  get tokenSecret() {
    return this._tokenSecret;
  }
};

// src/video/resources/uploads.ts
var PATH = "/video/v1/uploads";
var buildBasePath = (uploadId) => `${PATH}/${uploadId}`;
var Uploads = class extends Base {
  /**
   * Creates a direct upload with the specified JSON parameters
   * @extends Base
   * @param {Object} params - Upload JSON parameters (e.g timeout)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Video } = muxClient;
   *
   * // Create a new upload
   * const upload = await Video.Uploads.create({new_asset_settings: {playback_policy: 'public'}});
   * // Now push a file to the URL returned.
   * fs.createReadStream(pathToFile).pipe(request.put(upload.url))
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-direct-upload
   */
  create(params) {
    if (!params) {
      return Promise.reject(
        new Error("Params are required for creating a direct upload")
      );
    }
    return this.http.post(PATH, params);
  }
  /**
   * Cancels an upload
   * @param {string} uploadId - The ID for the upload intended for cancellation
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Cancels an upload
   * Video.Uploads.cancel(uploadId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/cancel-direct-upload
   */
  cancel(uploadId) {
    if (!uploadId) {
      return Promise.reject(new Error("An upload ID is required"));
    }
    return this.http.put(`${buildBasePath(uploadId)}/cancel`);
  }
  /**
   * Get an upload
   * @param {string} uploadId - The ID for the upload
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Get an upload
   * Video.Uploads.get(uploadId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-direct-upload
   */
  get(uploadId) {
    if (!uploadId) {
      return Promise.reject(
        new Error("An upload ID is required to get an asset")
      );
    }
    return this.http.get(buildBasePath(uploadId));
  }
  /**
   * List all uploads
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // List all uploads
   * Video.Uploads.list();
   *
   * @see https://docs.mux.com/api-reference/video#operation/list-direct-uploads
   */
  list(params) {
    return this.http.get(PATH, { params });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Uploads
});
/*!
 * Mux Assets
 * Copyright(c) 2018 Mux Inc.
 */
module.exports = module.exports.default || module.exports;
//# sourceMappingURL=uploads.js.map