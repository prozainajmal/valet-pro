// src/base.ts
import Axios from "axios";
import EventEmitter from "events";

// src/version.ts
var VERSION = "7.3.5";

// src/base.ts
var Base = class extends EventEmitter {
  constructor(tokenIdOrOptionsOrBase, tokenSecret, config) {
    var _a, _b, _c, _d, _e, _f, _g;
    super();
    if (tokenIdOrOptionsOrBase instanceof Base) {
      this.config = tokenIdOrOptionsOrBase._config;
      this._tokenId = tokenIdOrOptionsOrBase._tokenId;
      this._tokenSecret = tokenIdOrOptionsOrBase._tokenSecret;
      this.http = tokenIdOrOptionsOrBase.http;
    } else {
      if (typeof tokenIdOrOptionsOrBase === "object" && !(tokenIdOrOptionsOrBase instanceof Base)) {
        this.config = tokenIdOrOptionsOrBase;
        this.tokenId = void 0;
        this.tokenSecret = void 0;
      } else {
        this.tokenId = tokenIdOrOptionsOrBase;
        this.tokenSecret = tokenSecret;
        this.config = config ?? {};
      }
      const request = {
        baseURL: this.config.baseUrl,
        headers: {
          "User-Agent": `Mux Node | ${VERSION}`,
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        withCredentials: false,
        auth: {
          username: this._tokenId,
          password: this._tokenSecret
        }
      };
      if ((_a = this.config.platform) == null ? void 0 : _a.name) {
        if ((_c = (_b = this.config.platform) == null ? void 0 : _b.name) == null ? void 0 : _c.includes("|")) {
          throw new Error('Platform name cannot contain a "|" value.');
        }
        if ((_e = (_d = this.config.platform) == null ? void 0 : _d.version) == null ? void 0 : _e.includes("|")) {
          throw new Error('Platform version cannot contain a "|" value.');
        }
        request.headers["x-source-platform"] = `${(_f = this.config.platform) == null ? void 0 : _f.name} | ${(_g = this.config.platform) == null ? void 0 : _g.version}`;
      }
      this.http = Axios.create(request);
      this.http.interceptors.request.use((req) => {
        this.emit("request", req);
        return req;
      });
      this.http.interceptors.response.use(
        (res) => {
          this.emit("response", res);
          if (res.config.url && this.isVideoUrl(res.config.url)) {
            return res.data && res.data.data;
          }
          return res.data;
        },
        (errorRes) => Promise.reject(
          errorRes.response && errorRes.response.data.error || errorRes
        )
      );
    }
  }
  // eslint-disable-next-line class-methods-use-this
  isVideoUrl(url) {
    return url.startsWith(`/video/v1/`);
  }
  set config(options) {
    this._config = {
      baseUrl: "https://api.mux.com",
      ...options
    };
  }
  get config() {
    return this._config;
  }
  set tokenId(token) {
    const v = token || process.env.MUX_TOKEN_ID;
    if (!v || v.length === 0) {
      throw new Error("API Access Token must be provided.");
    }
    this._tokenId = v;
  }
  get tokenId() {
    return this._tokenId;
  }
  set tokenSecret(secret) {
    const v = secret || process.env.MUX_TOKEN_SECRET;
    if (!v || v.length === 0) {
      throw new Error("API secret key must be provided");
    }
    this._tokenSecret = v;
  }
  get tokenSecret() {
    return this._tokenSecret;
  }
};

// src/video/resources/liveStreams.ts
var PATH = "/video/v1/live-streams";
var buildBasePath = (liveStreamId) => `${PATH}/${liveStreamId}`;
var LiveStreams = class extends Base {
  /**
   * Creates a Mux live stream with the specified JSON parameters
   * @param {Object} params - Live Stream JSON parameters
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const muxClient = new Mux(accessToken, secret);
   * const { Video } = muxClient;
   *
   * // Create a live stream
   * Video.LiveStreams.create({
   *  playback_policy: 'public',
   *  new_asset_settings: { playback_policy: 'public' }
   * });
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-live-stream
   */
  create(params) {
    return this.http.post(PATH, params);
  }
  /**
   * Updates an existing livestream with new parameters.
   *
   * @param {string} liveStreamId - the ID of the live stream
   * @param {Object} params - Live Stream JSON parameters (e.g playback_policy)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   */
  async update(liveStreamId, params) {
    if (!liveStreamId || !params) {
      throw new Error("assetId and params are required.");
    }
    return this.http.patch(buildBasePath(liveStreamId), params);
  }
  /**
   * Deletes a Mux Live Stream
   * @param {string} liveStreamId - The ID for the live stream intended for deletion
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Delete a mux live stream
   * Video.LiveStreams.del(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/delete-live-stream
   */
  del(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to delete a live stream")
      );
    }
    return this.http.delete(buildBasePath(liveStreamId));
  }
  /**
   * Get an Live Stream
   * @param {string} liveStreamId - The ID for the live stream
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Get a live stream
   * Video.LiveStreams.get(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-live-stream
   */
  get(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to get a live stream")
      );
    }
    return this.http.get(buildBasePath(liveStreamId));
  }
  /**
   * List all live streams for a Mux Environment (tied to your access token)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // List all live streams for a Mux Environment
   * Video.LiveStreams.list();
   *
   * @see https://docs.mux.com/api-reference/video#operation/list-live-streams
   */
  list(params) {
    return this.http.get(PATH, { params });
  }
  /**
   * Signal a live stream is finished
   * @param {string} liveStreamId - The ID for the live stream
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Signal a live stream is finished
   * Video.LiveStreams.signalComplete(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/signal-live-stream-complete
   */
  signalComplete(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to signal a stream is complete")
      );
    }
    return this.http.put(`${buildBasePath(liveStreamId)}/complete`);
  }
  /**
   * Reset a stream key
   * @param {string} liveStreamId - The ID for the live stream
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Reset a live stream key if you want to immediately stop the current stream key
   * // from working and create a new stream key that can be used for future broadcasts.
   * Video.LiveStreams.resetStreamKey(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/reset-stream-key
   */
  resetStreamKey(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to reset a live stream key")
      );
    }
    return this.http.post(`${buildBasePath(liveStreamId)}/reset-stream-key`);
  }
  /**
   * Create a live stream playback id
   * @param {string} liveStreamId - The ID for the live stream
   * @param {Object} params - Live Stream JSON parameters (e.g playback_policy)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Create a live stream playback ID
   * Video.LiveStreams.createPlaybackId(liveStreamId, { policy: 'public' });
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-live-stream-playback-id
   */
  createPlaybackId(liveStreamId, params) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error(
          "A live stream ID is required to create a live stream playback ID"
        )
      );
    }
    if (!params) {
      return Promise.reject(
        new Error(
          "A playback policy is required to create a live stream playback ID"
        )
      );
    }
    return this.http.post(
      `${buildBasePath(liveStreamId)}/playback-ids`,
      params
    );
  }
  /**
   * Delete a live stream playback ID
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} playbackId - The ID for the live stream playback ID to delete
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Delete a live stream playback ID
   * Video.LiveStreams.deletePlaybackId(liveStreamId, { policy: 'public' });
   *
   * @see https://docs.mux.com/api-reference/video#operation/delete-live-stream-playback-id
   */
  deletePlaybackId(liveStreamId, playbackId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error(
          "A live stream ID is required to delete a live stream playback ID"
        )
      );
    }
    if (!playbackId) {
      return Promise.reject(
        new Error(
          "A live stream playback ID is required to delete a live stream playback ID"
        )
      );
    }
    return this.http.delete(
      `${buildBasePath(liveStreamId)}/playback-ids/${playbackId}`
    );
  }
  /**
   * Return a live stream playback id
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} playbackId - The ID for the playbackId
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-asset-playback-id
   */
  playbackId(liveStreamId, playbackId) {
    if (!liveStreamId) {
      return Promise.reject(new Error("A live stream ID is required"));
    }
    if (!playbackId) {
      return Promise.reject(new Error("A playback ID is required"));
    }
    return this.http.get(
      `${buildBasePath(liveStreamId)}/playback-ids/${playbackId}`
    );
  }
  /**
   * Create a simulcast target
   * @param {string} liveStreamId - The ID for the live stream
   * @param {Object} params - Simulcast Target JSON parameters (e.g url and stream_key)
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Create a live simulcast target
   * Video.LiveStreams.createSimulcastTarget(liveStreamId, {url: 'rtmp://live.example.com/app', stream_key: 'difvbfgi', passthrough: 'Example Live Streaming service'});
   *
   * @see https://docs.mux.com/api-reference/video#operation/create-live-stream-simulcast-target
   */
  createSimulcastTarget(liveStreamId, params) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to create a simulcast target")
      );
    }
    if (!(params && params.url)) {
      return Promise.reject(
        new Error("A url is required to create a simulcast target")
      );
    }
    return this.http.post(
      `${buildBasePath(liveStreamId)}/simulcast-targets`,
      params
    );
  }
  /**
   * Get a simulcast target
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} simulcastTargetId - The ID for the simulcast target to delete
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Get a live simulcast target
   * Video.LiveStreams.getSimulcastTarget(liveStreamId, simulcastTargetId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/get-live-stream-simulcast-target
   */
  getSimulcastTarget(liveStreamId, simulcastTargetId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to get a simulcast target")
      );
    }
    if (!simulcastTargetId) {
      return Promise.reject(
        new Error("A simulcast target ID is required to get a simulcast target")
      );
    }
    return this.http.get(
      `${buildBasePath(liveStreamId)}/simulcast-targets/${simulcastTargetId}`
    );
  }
  /**
   * Delete a simulcast target
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} simulcastTargetId - The ID for the simulcast target to delete
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Delete a simulcast target
   * Video.LiveStreams.deleteSimulcastTarget(liveStreamId, simulcastTargetId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/delete-live-stream-simulcast-target
   */
  deleteSimulcastTarget(liveStreamId, simulcastTargetId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to delete a simulcast target")
      );
    }
    if (!simulcastTargetId) {
      return Promise.reject(
        new Error(
          "A simulcast target ID is required to delete a simulcast target"
        )
      );
    }
    return this.http.delete(
      `${buildBasePath(liveStreamId)}/simulcast-targets/${simulcastTargetId}`
    );
  }
  /**
   * Configures a live stream to receive embedded closed captions.
   * The resulting Asset's subtitle text track will have `closed_captions: true` set.
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} params - Embedded subtitles parameters.
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   */
  async updateEmbeddedSubtitles(liveStreamId, params) {
    if (!liveStreamId || !params) {
      throw new Error("liveStreamId and params are required.");
    }
    return this.http.put(
      `${buildBasePath(liveStreamId)}/embedded-subtitles`,
      params
    );
  }
  /**
   * Configures a live stream to receive generated closed captions.
   * @param {string} liveStreamId - The ID for the live stream
   * @param {string} params - Generated subtitles parameters.
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   */
  async updateGeneratedSubtitles(liveStreamId, params) {
    if (!liveStreamId || !params) {
      throw new Error("liveStreamId and params are required.");
    }
    return this.http.put(
      `${buildBasePath(liveStreamId)}/generated-subtitles`,
      params
    );
  }
  /**
   * Disable a Live Stream
   * @param {string} liveStreamId - The ID for the live stream
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Disable a live stream
   * Video.LiveStreams.disable(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/disable-live-stream
   */
  disable(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to disable a live stream")
      );
    }
    return this.http.put(`${buildBasePath(liveStreamId)}/disable`);
  }
  /**
   * Enable a Live Stream
   * @param {string} liveStreamId - The ID for the live stream
   * @returns {Promise} - Returns a resolved Promise with a response from the Mux API
   *
   * @example
   * const { Video } = new Mux(accessToken, secret);
   *
   * // Enable a Live Stream
   * Video.LiveStreams.enable(liveStreamId);
   *
   * @see https://docs.mux.com/api-reference/video#operation/enable-live-stream
   */
  enable(liveStreamId) {
    if (!liveStreamId) {
      return Promise.reject(
        new Error("A live stream ID is required to enable a live stream")
      );
    }
    return this.http.put(`${buildBasePath(liveStreamId)}/enable`);
  }
};
export {
  LiveStreams
};
/*!
 * Mux Live Streams
 * Copyright(c) 2018 Mux Inc.
 */
//# sourceMappingURL=liveStreams.mjs.map